<!-- =========================================================================
     render-image.html — includes + robust image resolution (LFS/AVIF-safe)
     -------------------------------------------------------------------------
     Resolution order for images:
       0) Remote URL? → render directly (no transforms).
       1) Page Resources (.Page.Resources.GetMatch)
       2) Hugo Pipes via mounts:
            a) resources.Get $contentRel             (target="assets")
            b) resources.Get "content/<contentRel>"  (target="assets/content")
       3) Last resort: page-adjacent plain URL computed from .Page.File.Dir
          (Note: may 404 unless those files are published separately.)

     For Markdown includes:
       • If .Destination ends with .md, render that Markdown’s content inline.

     Safety:
       • Only transform when the file is truly raster AND not an LFS pointer AND
         not an AVIF/HEIC container accidentally named .jpg/.jpeg.
       • Uses only Go-template comments to avoid context-mismatch errors.
   ========================================================================= -->

{{- $dest := .Destination -}}
{{- $isRemote := or (strings.HasPrefix $dest "http://") (strings.HasPrefix $dest "https://") -}}
{{- $u := urls.Parse $dest -}}
{{- $path := $u.Path -}}


<!-- ======================= 1) MARKDOWN INCLUDE ======================= -->
{{- if and (not $isRemote) (strings.HasSuffix $path ".md") -}}
  <!-- Resolve the include path relative to the current page’s content dir -->
  {{- if and $path .Page.File -}}
    {{- if not (strings.HasPrefix $path "/") -}}
      {{- $path = path.Clean (path.Join .Page.File.Dir $path) -}}
    {{- else -}}
      {{- $path = strings.TrimPrefix "/" $path -}}
    {{- end -}}
  {{- end -}}

  {{- $base := strings.TrimSuffix ".md" $path -}}
  {{- $cands := slice
    $path
    (printf "%s.md" $base)
    (printf "%s/_index.md" (strings.TrimSuffix "/" $base))
  -}}

  {{- $included := false -}}
  {{- range $c := $cands -}}
    {{- if not $included -}}
      {{- with $.Page.Site.GetPage $c -}}
        <div data-pagefind-ignore>{{ .Content }}</div>
        {{- $included = true -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}

  {{- if not $included -}}
    <!-- Fallback: read raw file from /content and render without front matter -->
    {{- $probe := path.Clean (path.Join "content" $path) -}}
    {{- if not (fileExists $probe) -}}
      {{- $probe = path.Clean (path.Join "content" (strings.TrimPrefix "/" $path)) -}}
    {{- end -}}
    {{- if fileExists $probe -}}
      <div data-pagefind-ignore>
        {{- $raw := readFile $probe -}}
        {{- $nofm := replaceRE "^---[\\s\\S]+?---\\s*" "" $raw -}}
        {{- .Page.RenderString $nofm -}}
      </div>
    {{- end -}}
  {{- end -}}

{{- else -}}
  <!-- ============================ 2) IMAGES ============================ -->

  <!-- 2.0) Remote images: render directly, no transforms -->
  {{- if $isRemote -}}
    <a href="{{ $dest | safeURL }}" target="_self" rel="noopener">
      <img
        class="img-fluid"
        src="{{ $dest | safeURL }}"
        alt="{{ $.Text }}"
        loading="lazy"
        decoding="async"
      />
    </a>
  {{- else -}}
    <!-- 2.1) Page Resources (works for page bundles with index.md) -->
    {{- $img := .Page.Resources.GetMatch $dest -}}
    {{- if not $img -}}
      {{- $img = .Page.Resources.GetMatch (path.Base $path) -}}
    {{- end -}}


    <!-- Build path relative to /content for Hugo Pipes and disk probes -->
    {{- $contentRel := "" -}}
    {{- if strings.HasPrefix $path "/" -}}
      {{- $contentRel = strings.TrimPrefix "/" $path -}}
    {{- else -}}
      {{- $contentRel = path.Clean (path.Join .Page.File.Dir $path) -}}
    {{- end -}}


    <!-- 2.2) Hugo Pipes: target="assets" (no 'content/' prefix) -->
    {{- if not $img -}}
      {{- $img = resources.Get $contentRel -}}
    {{- end -}}


    <!-- 2.3) Hugo Pipes: target="assets/content" (with 'content/' prefix) -->
    {{- if not $img -}}
      {{- $img = resources.Get (printf "content/%s" (strings.TrimPrefix "content/" $contentRel)) -}}
    {{- end -}}

    {{- with $img -}}
      <!-- 2.4) Decide if we can safely transform:
            A) extension suggests a raster (jpg/jpeg/png/webp/gif/tif/tiff/bmp)
            B) on-disk bytes are NOT a Git-LFS pointer
            C) on-disk bytes are NOT an AVIF/HEIC/HEIF container mislabeled as jpg
         -->

      <!-- A) extension check -->
      {{- $name := .Name -}}
      {{- if not $name }}{{- $name = path.Base $path -}}{{- end -}}
      {{- $ext := lower (path.Ext $name) -}}
      {{- $rasterExts := slice ".jpg" ".jpeg" ".png" ".webp" ".gif" ".tif" ".tiff" ".bmp" -}}
      {{- $looksRaster := in $rasterExts $ext -}}


      <!-- Read a small prefix of the source file under /content for checks -->
      {{- $diskProbe := printf "content/%s" (strings.TrimPrefix "content/" $contentRel) -}}
      {{- $first := "" -}}
      {{- if fileExists $diskProbe -}}
        {{- $first = substr (readFile $diskProbe) 0 256 -}}
      {{- end -}}


      <!-- B) Git-LFS pointer? -->
      {{- $isLFSPointer := and (ne $first "") (strings.HasPrefix $first "version https://git-lfs.github.com/spec") -}}


      <!-- C) Container signature for AVIF/HEIC/HEIF (mislabeled as .jpg) -->
      {{- $isContainer := false -}}
      {{- if ne $first "" -}}
        {{- if or (in $first "ftypavif") (in $first "ftypavis") (in $first "ftypmif1")
          (in $first "ftypheic") (in $first "ftypheix") (in $first "ftypheif")
          (in $first "ftyphevc")
        -}}
          {{- $isContainer = true -}}
        {{- end -}}
      {{- end -}}

      {{- $canTransform := and $looksRaster (not $isLFSPointer) (not $isContainer) -}}

      {{- if $canTransform -}}
        <!-- Responsive pipeline from the ORIGINAL resource -->
        {{- $full   := . -}}
        {{- $large  := .Resize "1600x" -}}
        {{- $medium := .Resize   "1200x" -}}
        {{- $small  := .Resize     "800x" -}}


        <a href="{{ $full.RelPermalink }}" target="_self" rel="noopener">
          <img
            class="img-fluid"
            alt="{{ $.Text }}"
            src="{{ $small.RelPermalink }}"
            srcset="
              {{ $small.RelPermalink }}  800w,
              {{ $medium.RelPermalink }} 1200w,
              {{ $large.RelPermalink }} 1600w
            "
            sizes="(max-width: 900px) 90vw, 800px"
            loading="lazy"
            decoding="async"
            width="{{ $small.Width }}"
            height="{{ $small.Height }}"
          />
        </a>
      {{- else -}}
        <!-- Non-transformable (SVG/PDF/LFS/AVIF/HEIC). Emit original as-is. -->
        <a href="{{ .RelPermalink }}" target="_self" rel="noopener">
          <img
            class="img-fluid"
            src="{{ .RelPermalink }}"
            alt="{{ $.Text }}"
            loading="lazy"
            decoding="async"
          />
        </a>
      {{- end -}}

    {{- else -}}
      <!-- 2.5) Last resort: compute a page-adjacent URL from .Page.File.Dir -->
      {{- $destClean := strings.TrimPrefix "./" $dest -}}
      {{- $contentPath := path.Clean (path.Join .Page.File.Dir $destClean) -}}
      {{- $public := printf "/%s" (strings.TrimPrefix "content/" (strings.TrimPrefix "/" $contentPath)) -}}
      {{- $public = path.Clean $public -}}


      <a href="{{ $public | safeURL }}" target="_self" rel="noopener">
        <img
          class="img-fluid"
          src="{{ $public | safeURL }}"
          alt="{{ $.Text }}"
          loading="lazy"
          decoding="async"
        />
      </a>
    {{- end -}}
  {{- end -}}
{{- end -}}
