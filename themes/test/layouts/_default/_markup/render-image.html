<!-- =========================================================================
     render-image.html — Markdown includes + sibling-folder images (fast & safe)
     ---------------------------------------------------------------------------
     • ![…](something.md)
         1) Resolve as a content page and include its .Content
         2) Else read content/<path>.md (front matter stripped) and RenderString
     • ![…](image.*)
         1) Try page-bundle resource (.Page.Resources.GetMatch)
         2) Try /assets via resources.Get (pipeline-capable)
         3) SIBLING-FOLDER fallback (next to MD in /content):
              a) If mirrored in /static, use that public URL
              b) Else inline as data: URL (base64)
         4) Last-resort: output a plain <img> using the given URL
     Notes:
       • No .Site.Pages loops; minimal os.FileExists checks
       • Only pass STRING paths to os.FileExists/readFile
     ========================================================================= -->

{{- $dest := .Destination -}}
{{- $isRemote := or (strings.HasPrefix $dest "http://") (strings.HasPrefix $dest "https://") -}}
{{- $u := urls.Parse $dest -}}
{{- $path := $u.Path -}}
<!-- string, not a URL object -->

<!-- -------------------------------- INCLUDES -------------------------------- -->
{{- if and (not $isRemote) (strings.HasSuffix $path ".md") -}}
  <!-- Normalize include path against current page’s content dir -->
  {{- if and $path .Page.File -}}
    {{- if not (strings.HasPrefix $path "/") -}}
      {{- $path = path.Clean (path.Join .Page.File.Dir $path) -}}
      <!-- content-relative -->
    {{- else -}}
      {{- $path = strings.TrimPrefix "/" $path -}}
      <!-- content-root relative -->
    {{- end -}}
  {{- end -}}


  <!-- 1) Try as a content page (fast, no disk I/O) -->
  {{- $base := strings.TrimSuffix ".md" $path -}}
  {{- $cands := slice
    $path
    (printf "%s.md" $base)
    (printf "%s/_index.md" (strings.TrimSuffix "/" $base))
  -}}
  {{- $included := false -}}
  {{- range $c := $cands -}}
    {{- if not $included -}}
      {{- with $.Page.Site.GetPage $c -}}
        <div data-pagefind-ignore>{{ .Content }}</div>
        {{- $included = true -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}


  <!-- 2) Fallback: read file from /content and render it here -->
  {{- if not $included -}}
    {{- $probe := path.Clean (path.Join "content" $path) -}}
    {{- if not (os.FileExists $probe) -}}
      {{- $probe = path.Clean (path.Join "content" (strings.TrimPrefix "/" $path)) -}}
    {{- end -}}
    {{- if os.FileExists $probe -}}
      <div data-pagefind-ignore>
        {{- $raw := readFile $probe -}}
        {{- $nofm := replaceRE "^---[\\s\\S]+?---\\s*" "" $raw -}}
        {{- .Page.RenderString $nofm -}}
      </div>
    {{- else -}}
      <!-- include not found: {{ $path }} -->
    {{- end -}}
  {{- end -}}


  <!-- -------------------------------- IMAGES ---------------------------------- -->
{{- else -}}
  <!-- 1) Try page-bundle resource (fast & cacheable) -->
  {{- $img := .Page.Resources.GetMatch $dest -}}
  {{- if not $img -}}
    <!-- also try basename in case author wrote ../img.png -->
    {{- $img = .Page.Resources.GetMatch (path.Base $path) -}}
  {{- end -}}


  <!-- 2) Try /assets (pipeline-capable) -->
  {{- if not $img -}}
    {{- $assetsCand := strings.TrimPrefix "/" $path -}}
    {{- $assetsCand = strings.TrimPrefix "assets/" $assetsCand -}}
    {{- $img = resources.Get $assetsCand -}}
  {{- end -}}

  {{- with $img -}}
    <!-- Pipeline chain (adjust sizing to your taste) -->
    {{- $large  := .Resize "1200x" -}}
    {{- $medium := $large.Fill  "726x402 smart" -}}
    {{- $small  := $medium.Fill "458x254 smart" -}}
    <figure class="image-caption">
      <img
        alt="{{ $.Text }}"
        srcset="
          {{ $small.RelPermalink }}  458w,
          {{ $medium.RelPermalink }}  726w,
          {{ $large.RelPermalink }} 1200w
        "
        sizes="50vw"
        src="{{ $small.RelPermalink }}"
        class="img-fluid"
      />
      <figcaption>{{ with $.Title | safeHTML }}{{ . }}{{ end }}</figcaption>
    </figure>
  {{- else -}}
    <!-- ---------------- SIBLING-FOLDER FALLBACKS ---------------- -->

    <!-- 3a) Is there a sibling image file next to the MD in /content? -->
    {{- $sibDisk := "" -}}
    {{- if and .Page.File $path -}}
      {{- $joined := "" -}}
      {{- if not (strings.HasPrefix $path "/") -}}
        {{- $joined = path.Clean (path.Join .Page.File.Dir $path) -}}
      {{- else -}}
        {{- $joined = strings.TrimPrefix "/" $path -}}
      {{- end -}}
      {{- $probeContent := path.Clean (path.Join "content" $joined) -}}
      {{- if os.FileExists $probeContent -}}
        {{- $sibDisk = $probeContent -}}
      {{- end -}}
    {{- end -}}

    {{- if $sibDisk -}}
      <!-- 3b) If there is a mirrored copy under /static, serve public URL -->
      {{- $relFromContent := strings.TrimPrefix "content/" $sibDisk -}}
      {{- $staticDisk := path.Clean (path.Join "static" $relFromContent) -}}
      {{- if os.FileExists $staticDisk -}}
        {{- $publicURL := printf "/%s" (strings.TrimPrefix "/" $relFromContent) -}}
        <img
          class="img-fluid"
          src="{{ $publicURL | safeURL }}"
          alt="{{ $.Text }}"
        />
      {{- else -}}
        <!-- 3c) Inline the sibling image as a data: URL (keeps site working) -->
        {{- $raw := readFile $sibDisk -}}
        {{- $b64 := base64Encode $raw -}}
        {{- $ext := lower (path.Ext $sibDisk) -}}
        {{- $mime := cond (eq $ext ".png") "image/png"
          (cond (or (eq $ext ".jpg") (eq $ext ".jpeg")) "image/jpeg"
          (cond (eq $ext ".webp") "image/webp"
          (cond (eq $ext ".gif") "image/gif"
          (cond (eq $ext ".svg") "image/svg+xml" "application/octet-stream"))))
        -}}
        <img
          class="img-fluid"
          src="data:{{ $mime }};base64,{{ $b64 }}"
          alt="{{ $.Text }}"
        />
      {{- end -}}

    {{- else -}}
      <!-- 4) Last-resort: plain URL (for remote or already-public URLs) -->
      {{- $src := $dest -}}
      {{- if and (not $isRemote) (not (strings.HasPrefix $src "/")) -}}
        {{- $src = printf "/%s" (strings.TrimPrefix "/" $src) -}}
      {{- end -}}
      <img class="img-fluid" src="{{ $src | safeURL }}" alt="{{ $.Text }}" />
    {{- end -}}
  {{- end -}}
{{- end -}}
