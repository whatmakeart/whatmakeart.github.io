<!-- =========================================================================
     render-image.html — includes + robust image resolution (original-link via Copy)
     -------------------------------------------------------------------------
     What this does:
       • If .Destination ends with .md → include that Markdown (rendered).
       • Else resolve local images in this order:
           1) Page Resources (.Page.Resources.GetMatch)
           2) Hugo Pipes via your mounts:
                a) resources.Get $contentRel             (target="assets")
                b) resources.Get "content/<contentRel>"  (target="assets/content")
         Then:
           • Make an on-demand, ORIGINAL-NAMED public copy:
               $orig := $img | resources.Copy $origTarget
             where $origTarget == "courses/.../image.jpg" (no "content/" prefix).
           • <a href> → $orig.RelPermalink  (original name/path)
           • <img src/srcset> → resized variants when safe; else $orig.RelPermalink
       • Remote images are linked directly (no transforms).
       • Last resort: page-adjacent URL from .Page.File.Dir (if unresolved).

     Safety:
       • Only transform when bytes are truly raster AND not LFS pointer AND not AVIF/HEIC
         mislabeled as .jpg/.jpeg (magic-brand check).
       • Go-template comments only (avoid context errors).
   ========================================================================= -->

{{- $dest := .Destination -}}
{{- $isRemote := or (strings.HasPrefix $dest "http://") (strings.HasPrefix $dest "https://") -}}
{{- $u := urls.Parse $dest -}}
{{- $path := $u.Path -}}


<!-- ======================= 1) MARKDOWN INCLUDE ======================= -->
{{- if and (not $isRemote) (strings.HasSuffix $path ".md") -}}
  {{- if and $path .Page.File -}}
    {{- if not (strings.HasPrefix $path "/") -}}
      {{- $path = path.Clean (path.Join .Page.File.Dir $path) -}}
    {{- else -}}
      {{- $path = strings.TrimPrefix "/" $path -}}
    {{- end -}}
  {{- end -}}

  {{- $base := strings.TrimSuffix ".md" $path -}}
  {{- $cands := slice
    $path
    (printf "%s.md" $base)
    (printf "%s/_index.md" (strings.TrimSuffix "/" $base))
  -}}
  {{- $included := false -}}
  {{- range $c := $cands -}}
    {{- if not $included -}}
      {{- with $.Page.Site.GetPage $c -}}
        <div data-pagefind-ignore>{{ .Content }}</div>
        {{- $included = true -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}

  {{- if not $included -}}
    {{- $probe := path.Clean (path.Join "content" $path) -}}
    {{- if not (fileExists $probe) -}}
      {{- $probe = path.Clean (path.Join "content" (strings.TrimPrefix "/" $path)) -}}
    {{- end -}}
    {{- if fileExists $probe -}}
      <div data-pagefind-ignore>
        {{- $raw := readFile $probe -}}
        {{- $nofm := replaceRE "^---[\\s\\S]+?---\\s*" "" $raw -}}
        {{- .Page.RenderString $nofm -}}
      </div>
    {{- end -}}
  {{- end -}}

{{- else -}}
  <!-- ============================ 2) IMAGES ============================ -->

  {{- if $isRemote -}}
    <a href="{{ $dest | safeURL }}" target="_self" rel="noopener">
      <img
        class="img-fluid"
        src="{{ $dest | safeURL }}"
        alt="{{ $.Text }}"
        loading="lazy"
        decoding="async"
      />
    </a>
  {{- else -}}
    <!-- Build path relative to /content for lookups and for ORIGINAL link -->
    {{- $contentRel := "" -}}
    {{- if strings.HasPrefix $path "/" -}}
      {{- $contentRel = strings.TrimPrefix "/" $path -}}
    {{- else -}}
      {{- $contentRel = path.Clean (path.Join .Page.File.Dir $path) -}}
    {{- end -}}


    <!-- 2.1) Page Resources (bundles) -->
    {{- $img := .Page.Resources.GetMatch $dest -}}
    {{- if not $img -}}
      {{- $img = .Page.Resources.GetMatch (path.Base $path) -}}
    {{- end -}}


    <!-- 2.2) Hugo Pipes via mounts -->
    {{- if not $img -}}
      {{- $img = resources.Get $contentRel -}}
      {{/* target="assets" */}}
    {{- end -}}
    {{- if not $img -}}
      {{- $img = resources.Get (printf "content/%s" (strings.TrimPrefix "content/" $contentRel)) -}}
      {{/* target="assets/content" */}}
    {{- end -}}

    {{- with $img -}}
      <!-- Create ORIGINAL-NAMED public copy on demand (no extra mounts needed) -->
      {{- $origTarget := strings.TrimPrefix "content/" $contentRel -}}
      {{/* e.g., courses/.../image.jpg */}}
      {{- $orig := . | resources.Copy $origTarget -}}
      {{/* href uses this */}}


      <!-- Decide if we can transform safely -->
      {{- $name := .Name -}}
      {{- if not $name }}{{- $name = path.Base $path -}}{{- end -}}
      {{- /* Check if image is over 1MB (1,048,576 bytes) */ -}}
      {{- $isLargeEnough := ge (len .Content) 1048576 -}}
      {{- $ext := lower (path.Ext $name) -}}
      {{- $rasterExts := slice ".jpg" ".jpeg" ".png" ".webp" ".gif" ".tif" ".tiff" ".bmp" -}}
      {{- $looksRaster := in $rasterExts $ext -}}

      {{- $diskProbe := printf "content/%s" (strings.TrimPrefix "content/" $contentRel) -}}
      {{- $first := "" -}}
      {{- if fileExists $diskProbe -}}
        {{- $first = substr (readFile $diskProbe) 0 256 -}}
      {{- end -}}
      {{- $isLFSPointer := and (ne $first "") (strings.HasPrefix $first "version https://git-lfs.github.com/spec") -}}
      {{- $isContainer := false -}}
      {{- if ne $first "" -}}
        {{- if or (in $first "ftypavif") (in $first "ftypavis") (in $first "ftypmif1")
          (in $first "ftypheic") (in $first "ftypheix") (in $first "ftypheif")
          (in $first "ftyphevc")
        -}}
          {{- $isContainer = true -}}
        {{- end -}}
      {{- end -}}
      {{- $canTransform := and $looksRaster (not $isLFSPointer) (not $isContainer) $isLargeEnough -}}

      {{- if $canTransform -}}
        {{- $large  := .Resize "1600x" -}}
        {{- $medium := .Resize    "1200x" -}}
        {{- $small  := .Resize    "800x" -}}
        <a
          href="{{ $orig.RelPermalink | safeURL }}"
          target="_self"
          rel="noopener"
        >
          <img
            class="img-fluid"
            alt="{{ $.Text }}"
            src="{{ $small.RelPermalink }}"
            srcset="
              {{ $small.RelPermalink }}  800w,
              {{ $medium.RelPermalink }} 1200w,
              {{ $large.RelPermalink }} 1600w
            "
            sizes="(max-width: 900px) 90vw, 800px"
            loading="lazy"
            decoding="async"
            width="{{ $small.Width }}"
            height="{{ $small.Height }}"
          />
        </a>
      {{- else -}}
        <a
          href="{{ $orig.RelPermalink | safeURL }}"
          target="_self"
          rel="noopener"
        >
          <img
            class="img-fluid"
            src="{{ $orig.RelPermalink | safeURL }}"
            alt="{{ $.Text }}"
            loading="lazy"
            decoding="async"
          />
        </a>
      {{- end -}}

    {{- else -}}
      <!-- 2.3) Last resort: page-adjacent URL (no Copy, just computed path) -->
      {{- $originalURL := printf "/%s" (strings.TrimPrefix "content/" (strings.TrimPrefix "/" $contentRel)) -}}
      {{- $originalURL = path.Clean $originalURL -}}
      <a href="{{ $originalURL | safeURL }}" target="_self" rel="noopener">
        <img
          class="img-fluid"
          src="{{ $originalURL | safeURL }}"
          alt="{{ $.Text }}"
          loading="lazy"
          decoding="async"
        />
      </a>
    {{- end -}}
  {{- end -}}
{{- end -}}
